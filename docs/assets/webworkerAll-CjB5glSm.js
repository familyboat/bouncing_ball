import{D as pe,u as F,a as U,B as te,E as w,M as re,b as y,c as S,w as me,e as ie}from"./index-C9j-uYXp.js";const k=Object.create(null),K=Object.create(null);function W(s,e){let t=K[s];return t===void 0&&(k[e]===void 0&&(k[e]=1),K[s]=t=k[e]++),t}let R;function ge(){return(!R||R?.isContextLost())&&(R=pe.get().createCanvas().getContext("webgl",{})),R}let G;function xe(){if(!G){G="mediump";const s=ge();s&&s.getShaderPrecisionFormat&&(G=s.getShaderPrecisionFormat(s.FRAGMENT_SHADER,s.HIGH_FLOAT).precision?"highp":"mediump")}return G}function be(s,e,t){return e?s:t?(s=s.replace("out vec4 finalColor;",""),`

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${s}
        `):`

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${s}
        `}function _e(s,e,t){const r=t?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if(s.substring(0,9)!=="precision"){let i=t?e.requestedFragmentPrecision:e.requestedVertexPrecision;return i==="highp"&&r!=="highp"&&(i="mediump"),`precision ${i} float;
${s}`}else if(r!=="highp"&&s.substring(0,15)==="precision highp")return s.replace("precision highp","precision mediump");return s}function ye(s,e){return e?`#version 300 es
${s}`:s}const Te={},Fe={};function ve(s,{name:e="pixi-program"},t=!0){e=e.replace(/\s+/g,"-"),e+=t?"-fragment":"-vertex";const r=t?Te:Fe;return r[e]?(r[e]++,e+=`-${r[e]}`):r[e]=1,s.indexOf("#define SHADER_NAME")!==-1?s:`${`#define SHADER_NAME ${e}`}
${s}`}function Pe(s,e){return e?s.replace("#version 300 es",""):s}const I={stripVersion:Pe,ensurePrecision:_e,addProgramDefines:be,setProgramName:ve,insertVersion:ye},v=Object.create(null),se=class N{constructor(e){e={...N.defaultOptions,...e};const t=e.fragment.indexOf("#version 300 es")!==-1,r={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:xe()},setProgramName:{name:e.name},addProgramDefines:t,insertVersion:t};let i=e.fragment,n=e.vertex;Object.keys(I).forEach(o=>{const a=r[o];i=I[o](i,a,!0),n=I[o](n,a,!1)}),this.fragment=i,this.vertex=n,this.transformFeedbackVaryings=e.transformFeedbackVaryings,this._key=W(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null,v[this._cacheKey]=null}static from(e){const t=`${e.vertex}:${e.fragment}`;return v[t]||(v[t]=new N(e),v[t]._cacheKey=t),v[t]}};se.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let j=se;const H={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function we(s){return H[s]??H.float32}const Ee={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",vec2i:"sint32x2",vec3i:"sint32x3",vec4i:"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",vec2u:"uint32x2",vec3u:"uint32x3",vec4u:"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"},Q=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|\)|$)/g;function Z(s,e){let t;for(;(t=Q.exec(s))!==null;){const r=Ee[t[3]]??"float32";e[t[2]]={location:parseInt(t[1],10),format:r,stride:we(r).stride,offset:0,instance:!1,start:0}}Q.lastIndex=0}function Se(s){return s.replace(/\/\/.*$/gm,"").replace(/\/\*[\s\S]*?\*\//g,"")}function Re({source:s,entryPoint:e}){const t={},r=Se(s),i=r.indexOf(`fn ${e}(`);if(i===-1)return t;const n=r.indexOf("->",i);if(n===-1)return t;const o=r.substring(i,n);if(Z(o,t),Object.keys(t).length===0){const a=o.match(/\(\s*\w+\s*:\s*(\w+)/);if(a){const f=a[1],c=new RegExp(`struct\\s+${f}\\s*\\{([^}]+)\\}`,"s"),l=r.match(c);l&&Z(l[1],t)}}return t}function M(s){const e=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,t=/@group\((\d+)\)/,r=/@binding\((\d+)\)/,i=/var(<[^>]+>)? (\w+)/,n=/:\s*([\w<>]+)/,o=/struct\s+(\w+)\s*{([^}]+)}/g,a=/(\w+)\s*:\s*([\w\<\>]+)/g,f=/struct\s+(\w+)/,c=s.match(e)?.map(u=>({group:parseInt(u.match(t)[1],10),binding:parseInt(u.match(r)[1],10),name:u.match(i)[2],isUniform:u.match(i)[1]==="<uniform>",type:u.match(n)[1]}));if(!c)return{groups:[],structs:[]};const l=s.match(o)?.map(u=>{const d=u.match(f)[1],h=u.match(a).reduce((p,m)=>{const[_,g]=m.split(":");return p[_.trim()]=g.trim(),p},{});return h?{name:d,members:h}:null}).filter(({name:u})=>c.some(d=>d.type===u||d.type.includes(`<${u}>`)))??[];return{groups:c,structs:l}}var T=(s=>(s[s.VERTEX=1]="VERTEX",s[s.FRAGMENT=2]="FRAGMENT",s[s.COMPUTE=4]="COMPUTE",s))(T||{});function Ge({groups:s}){const e=[];for(let t=0;t<s.length;t++){const r=s[t];e[r.group]||(e[r.group]=[]),r.isUniform?e[r.group].push({binding:r.binding,visibility:T.VERTEX|T.FRAGMENT,buffer:{type:"uniform"}}):r.type==="sampler"?e[r.group].push({binding:r.binding,visibility:T.FRAGMENT,sampler:{type:"filtering"}}):r.type==="texture_2d"||r.type.startsWith("texture_2d<")?e[r.group].push({binding:r.binding,visibility:T.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}}):r.type==="texture_2d_array"||r.type.startsWith("texture_2d_array<")?e[r.group].push({binding:r.binding,visibility:T.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d-array",multisampled:!1}}):(r.type==="texture_cube"||r.type.startsWith("texture_cube<"))&&e[r.group].push({binding:r.binding,visibility:T.FRAGMENT,texture:{sampleType:"float",viewDimension:"cube",multisampled:!1}})}for(let t=0;t<e.length;t++)e[t]||(e[t]=[]);return e}function Ae({groups:s}){const e=[];for(let t=0;t<s.length;t++){const r=s[t];e[r.group]||(e[r.group]={}),e[r.group][r.name]=r.binding}return e}function Oe(s,e){const t=new Set,r=new Set,i=[...s.structs,...e.structs].filter(o=>t.has(o.name)?!1:(t.add(o.name),!0)),n=[...s.groups,...e.groups].filter(o=>{const a=`${o.name}-${o.binding}`;return r.has(a)?!1:(r.add(a),!0)});return{structs:i,groups:n}}const P=Object.create(null);class E{constructor(e){this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:t,vertex:r,layout:i,gpuLayout:n,name:o}=e;if(this.name=o,this.fragment=t,this.vertex=r,t.source===r.source){const a=M(t.source);this.structsAndGroups=a}else{const a=M(r.source),f=M(t.source);this.structsAndGroups=Oe(a,f)}this.layout=i??Ae(this.structsAndGroups),this.gpuLayout=n??Ge(this.structsAndGroups),this.autoAssignGlobalUniforms=this.layout[0]?.globalUniforms!==void 0,this.autoAssignLocalUniforms=this.layout[1]?.localUniforms!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,r=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=W(r,"program")}get attributeData(){return this._attributeData??(this._attributeData=Re(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null,P[this._cacheKey]=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return P[t]||(P[t]=new E(e),P[t]._cacheKey=t),P[t]}}const ne=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],ke=ne.reduce((s,e)=>(s[e]=!0,s),{});function Ie(s,e){switch(s){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const oe=class ae{constructor(e,t){this._touched=0,this.uid=F("uniform"),this._resourceType="uniformGroup",this._resourceId=F("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,t={...ae.defaultOptions,...t},this.uniformStructures=e;const r={};for(const i in e){const n=e[i];if(n.name=i,n.size=n.size??1,!ke[n.type]){const o=n.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);if(o){const[,a,f]=o;throw new Error(`Uniform type ${n.type} is not supported. Use type: '${a}', size: ${f} instead.`)}throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${ne.join(", ")}`)}n.value??(n.value=Ie(n.type,n.size)),r[i]=n.value}this.uniforms=r,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=W(Object.keys(r).map(i=>`${i}-${e[i].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};oe.defaultOptions={ubo:!1,isStatic:!1};let ue=oe;class A{constructor(e){this.resources=Object.create(null),this._dirty=!0;let t=0;for(const r in e){const i=e[r];this.setResource(i,t++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const e=[];let t=0;for(const r in this.resources)e[t++]=this.resources[r]._resourceId;this._key=e.join("|")}setResource(e,t){const r=this.resources[t];e!==r&&(r&&e.off?.("change",this.onResourceChange,this),e.on?.("change",this.onResourceChange,this),this.resources[t]=e,this._dirty=!0)}getResource(e){return this.resources[e]}_touch(e,t){const r=this.resources;for(const i in r)r[i]._gcLastUsed=e,r[i]._touched=t}destroy(){const e=this.resources;for(const t in e)e[t]?.off?.("change",this.onResourceChange,this);this.resources=null}onResourceChange(e){if(this._dirty=!0,e.destroyed){const t=this.resources;for(const r in t)t[r]===e&&(t[r]=null)}else this._updateKey()}}var O=(s=>(s[s.WEBGL=1]="WEBGL",s[s.WEBGPU=2]="WEBGPU",s[s.CANVAS=4]="CANVAS",s[s.BOTH=3]="BOTH",s))(O||{});class q extends U{constructor(e){super(),this.uid=F("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[],this._destroyed=!1;let{gpuProgram:t,glProgram:r,groups:i,resources:n,compatibleRenderers:o,groupMap:a}=e;this.gpuProgram=t,this.glProgram=r,o===void 0&&(o=0,t&&(o|=O.WEBGPU),r&&(o|=O.WEBGL)),this.compatibleRenderers=o;const f={};if(!n&&!i&&(n={}),n&&i)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&i&&!a)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&i&&a)for(const c in a)for(const l in a[c]){const u=a[c][l];f[u]={group:c,binding:l,name:u}}else if(t&&i&&!a){const c=t.structsAndGroups.groups;a={},c.forEach(l=>{a[l.group]=a[l.group]||{},a[l.group][l.binding]=l.name,f[l.name]=l})}else if(n){i={},a={},t&&t.structsAndGroups.groups.forEach(u=>{a[u.group]=a[u.group]||{},a[u.group][u.binding]=u.name,f[u.name]=u});let c=0;for(const l in n)f[l]||(i[99]||(i[99]=new A,this._ownedBindGroups.push(i[99])),f[l]={group:99,binding:c,name:l},a[99]=a[99]||{},a[99][c]=l,c++);for(const l in n){const u=l;let d=n[l];!d.source&&!d._resourceType&&(d=new ue(d));const h=f[u];h&&(i[h.group]||(i[h.group]=new A,this._ownedBindGroups.push(i[h.group])),i[h.group].setResource(d,h.binding))}}this.groups=i,this._uniformBindMap=a,this.resources=this._buildResourceAccessor(i,f)}addResource(e,t,r){var i,n;(i=this._uniformBindMap)[t]||(i[t]={}),(n=this._uniformBindMap[t])[r]||(n[r]=e),this.groups[t]||(this.groups[t]=new A,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const r={};for(const i in t){const n=t[i];Object.defineProperty(r,n.name,{get(){return e[n.group].getResource(n.binding)},set(o){e[n.group].setResource(o,n.binding)}})}return r}destroy(e=!1){this._destroyed||(this._destroyed=!0,this.emit("destroy",this),e&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(t=>{t.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null)}static from(e){const{gpu:t,gl:r,...i}=e;let n,o;return t&&(n=E.from(t)),r&&(o=j.from(r)),new q({gpuProgram:n,glProgram:o,...i})}}const Me={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},C=0,z=1,D=2,B=3,L=4,V=5,$=class le{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<C)}set blend(e){!!(this.data&1<<C)!==e&&(this.data^=1<<C)}get offsets(){return!!(this.data&1<<z)}set offsets(e){!!(this.data&1<<z)!==e&&(this.data^=1<<z)}set cullMode(e){if(e==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=e==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<D)}set culling(e){!!(this.data&1<<D)!==e&&(this.data^=1<<D)}get depthTest(){return!!(this.data&1<<B)}set depthTest(e){!!(this.data&1<<B)!==e&&(this.data^=1<<B)}get depthMask(){return!!(this.data&1<<V)}set depthMask(e){!!(this.data&1<<V)!==e&&(this.data^=1<<V)}get clockwiseFrontFace(){return!!(this.data&1<<L)}set clockwiseFrontFace(e){!!(this.data&1<<L)!==e&&(this.data^=1<<L)}get blendMode(){return this._blendMode}set blendMode(e){this.blend=e!=="none",this._blendMode=e,this._blendModeId=Me[e]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const e=new le;return e.depthTest=!1,e.blend=!0,e}};$.default2d=$.for2d();let Ce=$;const ce=class Y extends q{constructor(e){e={...Y.defaultOptions,...e},super(e),this.enabled=!0,this._state=Ce.for2d(),this.blendMode=e.blendMode,this.padding=e.padding,typeof e.antialias=="boolean"?this.antialias=e.antialias?"on":"off":this.antialias=e.antialias,this.resolution=e.resolution,this.blendRequired=e.blendRequired,this.clipToViewport=e.clipToViewport,this.addResource("uTexture",0,1),e.blendRequired&&this.addResource("uBackTexture",0,3)}apply(e,t,r,i){e.applyFilter(this,t,r,i)}get blendMode(){return this._state.blendMode}set blendMode(e){this._state.blendMode=e}static from(e){const{gpu:t,gl:r,...i}=e;let n,o;return t&&(n=E.from(t)),r&&(o=j.from(r)),new Y({gpuProgram:n,glProgram:o,...i})}};ce.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let ze=ce;var b=(s=>(s[s.MAP_READ=1]="MAP_READ",s[s.MAP_WRITE=2]="MAP_WRITE",s[s.COPY_SRC=4]="COPY_SRC",s[s.COPY_DST=8]="COPY_DST",s[s.INDEX=16]="INDEX",s[s.VERTEX=32]="VERTEX",s[s.UNIFORM=64]="UNIFORM",s[s.STORAGE=128]="STORAGE",s[s.INDIRECT=256]="INDIRECT",s[s.QUERY_RESOLVE=512]="QUERY_RESOLVE",s[s.STATIC=1024]="STATIC",s))(b||{});class X extends U{constructor(e){let{data:t,size:r}=e;const{usage:i,label:n,shrinkToFit:o}=e;super(),this._gpuData=Object.create(null),this._gcLastUsed=-1,this.autoGarbageCollect=!0,this.uid=F("buffer"),this._resourceType="buffer",this._resourceId=F("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,t instanceof Array&&(t=new Float32Array(t)),this._data=t,r??(r=t?.byteLength);const a=!!t;this.descriptor={size:r,usage:i,mappedAtCreation:a,label:n},this.shrinkToFit=o??!0}get data(){return this._data}set data(e){this.setDataWithSize(e,e.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&b.STATIC)}set static(e){e?this.descriptor.usage|=b.STATIC:this.descriptor.usage&=~b.STATIC}setDataWithSize(e,t,r){if(this._updateID++,this._updateSize=t*e.BYTES_PER_ELEMENT,this._data===e){r&&this.emit("update",this);return}const i=this._data;if(this._data=e,this._dataInt32=null,!i||i.length!==e.length){!this.shrinkToFit&&i&&e.byteLength<i.byteLength?r&&this.emit("update",this):(this.descriptor.size=e.byteLength,this._resourceId=F("resource"),this.emit("change",this));return}r&&this.emit("update",this)}update(e){this._updateSize=e??this._updateSize,this._updateID++,this.emit("update",this)}unload(){this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy();this._gpuData=Object.create(null)}destroy(){this.destroyed=!0,this.unload(),this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function de(s,e){if(!(s instanceof X)){let t=e?b.INDEX:b.VERTEX;s instanceof Array&&(e?(s=new Uint32Array(s),t=b.INDEX|b.COPY_DST):(s=new Float32Array(s),t=b.VERTEX|b.COPY_DST)),s=new X({data:s,label:e?"index-mesh-buffer":"vertex-mesh-buffer",usage:t})}return s}function De(s,e,t){const r=s.getAttribute(e);if(!r)return t.minX=0,t.minY=0,t.maxX=0,t.maxY=0,t;const i=r.buffer.data;let n=1/0,o=1/0,a=-1/0,f=-1/0;const c=i.BYTES_PER_ELEMENT,l=(r.offset||0)/c,u=(r.stride||8)/c;for(let d=l;d<i.length;d+=u){const h=i[d],p=i[d+1];h>a&&(a=h),p>f&&(f=p),h<n&&(n=h),p<o&&(o=p)}return t.minX=n,t.minY=o,t.maxX=a,t.maxY=f,t}function Be(s){return(s instanceof X||Array.isArray(s)||s.BYTES_PER_ELEMENT)&&(s={buffer:s}),s.buffer=de(s.buffer,!1),s}class Le extends U{constructor(e={}){super(),this._gpuData=Object.create(null),this.autoGarbageCollect=!0,this._gcLastUsed=-1,this.uid=F("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new te,this._boundsDirty=!0;const{attributes:t,indexBuffer:r,topology:i}=e;if(this.buffers=[],this.attributes={},t)for(const n in t)this.addAttribute(n,t[n]);this.instanceCount=e.instanceCount??1,r&&this.addIndex(r),this.topology=i||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(e){return this.attributes[e]}getIndex(){return this.indexBuffer}getBuffer(e){return this.getAttribute(e).buffer}getSize(){for(const e in this.attributes){const t=this.attributes[e];return t.buffer.data.length/(t.stride/4||t.size)}return 0}addAttribute(e,t){const r=Be(t);this.buffers.indexOf(r.buffer)===-1&&(this.buffers.push(r.buffer),r.buffer.on("update",this.onBufferUpdate,this),r.buffer.on("change",this.onBufferUpdate,this)),this.attributes[e]=r}addIndex(e){this.indexBuffer=de(e,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,De(this,"aPosition",this._bounds)):this._bounds}unload(){this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy();this._gpuData=Object.create(null)}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners(),e&&this.buffers.forEach(t=>t.destroy()),this.unload(),this.indexBuffer?.destroy(),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}var Ve=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,Ne=`in vec2 vTextureCoord;
out vec4 finalColor;
uniform sampler2D uTexture;
void main() {
    finalColor = texture(uTexture, vTextureCoord);
}
`,J=`struct GlobalFilterUniforms {
  uInputSize: vec4<f32>,
  uInputPixel: vec4<f32>,
  uInputClamp: vec4<f32>,
  uOutputFrame: vec4<f32>,
  uGlobalFrame: vec4<f32>,
  uOutputTexture: vec4<f32>,
};

@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler: sampler;

struct VSOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>
};

fn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition: vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {
    return textureSample(uTexture, uSampler, uv);
}
`;class $e extends ze{constructor(){const e=E.from({vertex:{source:J,entryPoint:"mainVertex"},fragment:{source:J,entryPoint:"mainFragment"},name:"passthrough-filter"}),t=j.from({vertex:Ve,fragment:Ne,name:"passthrough-filter"});super({gpuProgram:e,glProgram:t})}}class fe{constructor(e){this._renderer=e}push(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:t,filterEffect:e})}pop(e,t,r){this._renderer.renderPipes.batch.break(r),r.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(e){e.action==="pushFilter"?this._renderer.filter.push(e):e.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}fe.extension={type:[w.WebGLPipes,w.WebGPUPipes,w.CanvasPipes],name:"filter"};const ee=new re;function Ye(s,e){e.clear();const t=e.matrix;for(let r=0;r<s.length;r++){const i=s[r];if(i.globalDisplayStatus<7)continue;const n=i.renderGroup??i.parentRenderGroup;n?.isCachedAsTexture?e.matrix=ee.copyFrom(n.textureOffsetInverseTransform).append(i.worldTransform):n?._parentCacheAsTextureRenderGroup?e.matrix=ee.copyFrom(n._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(i.groupTransform):e.matrix=i.worldTransform,e.addBounds(i.bounds)}return e.matrix=t,e}const Xe=new Le({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class Ue{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new te,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class he{constructor(e){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new ue({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new A({}),this.renderer=e}get activeBackTexture(){return this._activeFilterData?.backTexture}push(e){const t=this.renderer,r=e.filterEffect.filters,i=this._pushFilterData();i.skip=!1,i.filters=r,i.container=e.container,i.outputRenderSurface=t.renderTarget.renderSurface;const n=t.renderTarget.renderTarget.colorTexture.source,o=n.resolution,a=n.antialias;if(r.every(h=>!h.enabled)){i.skip=!0;return}const f=i.bounds;if(this._calculateFilterArea(e,f),this._calculateFilterBounds(i,t.renderTarget.rootViewPort,a,o,1),i.skip)return;const c=this._getPreviousFilterData(),l=this._findFilterResolution(o);let u=0,d=0;c&&(u=c.bounds.minX,d=c.bounds.minY),this._calculateGlobalFrame(i,u,d,l,n.width,n.height),this._setupFilterTextures(i,f,t,c)}generateFilteredTexture({texture:e,filters:t}){const r=this._pushFilterData();this._activeFilterData=r,r.skip=!1,r.filters=t;const i=e.source,n=i.resolution,o=i.antialias;if(t.every(h=>!h.enabled))return r.skip=!0,e;const a=r.bounds;if(a.addRect(e.frame),this._calculateFilterBounds(r,a.rectangle,o,n,0),r.skip)return e;const f=n;this._calculateGlobalFrame(r,0,0,f,i.width,i.height),r.outputRenderSurface=y.getOptimalTexture(a.width,a.height,r.resolution,r.antialias),r.backTexture=S.EMPTY,r.inputTexture=e,this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(r,!0);const d=r.outputRenderSurface;return d.source.alphaMode="premultiplied-alpha",d}pop(){const e=this.renderer,t=this._popFilterData();t.skip||(e.globalUniforms.pop(),e.renderTarget.finishRenderPass(),this._activeFilterData=t,this._applyFiltersToTexture(t,!1),t.blendRequired&&y.returnTexture(t.backTexture),y.returnTexture(t.inputTexture))}getBackTexture(e,t,r){const i=e.colorTexture.source._resolution,n=y.getOptimalTexture(t.width,t.height,i,!1);let o=t.minX,a=t.minY;r&&(o-=r.minX,a-=r.minY),o=Math.floor(o*i),a=Math.floor(a*i);const f=Math.ceil(t.width*i),c=Math.ceil(t.height*i);return this.renderer.renderTarget.copyToTexture(e,n,{x:o,y:a},{width:f,height:c},{x:0,y:0}),n}applyFilter(e,t,r,i){const n=this.renderer,o=this._activeFilterData,f=o.outputRenderSurface===r,c=n.renderTarget.rootRenderTarget.colorTexture.source._resolution,l=this._findFilterResolution(c);let u=0,d=0;if(f){const p=this._findPreviousFilterOffset();u=p.x,d=p.y}this._updateFilterUniforms(t,r,o,u,d,l,f,i);const h=e.enabled?e:this._getPassthroughFilter();this._setupBindGroupsAndRender(h,t,n)}calculateSpriteMatrix(e,t){const r=this._activeFilterData,i=e.set(r.inputTexture._source.width,0,0,r.inputTexture._source.height,r.bounds.minX,r.bounds.minY),n=t.worldTransform.copyTo(re.shared),o=t.renderGroup||t.parentRenderGroup;return o&&o.cacheToLocalTransform&&n.prepend(o.cacheToLocalTransform),n.invert(),i.prepend(n),i.scale(1/t.texture.orig.width,1/t.texture.orig.height),i.translate(t.anchor.x,t.anchor.y),i}destroy(){this._passthroughFilter?.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){return this._passthroughFilter??(this._passthroughFilter=new $e),this._passthroughFilter}_setupBindGroupsAndRender(e,t,r){if(r.renderPipes.uniformBatch){const i=r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(i,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(t.source,1),this._globalFilterBindGroup.setResource(t.source.style,2),e.groups[0]=this._globalFilterBindGroup,r.encoder.draw({geometry:Xe,shader:e,state:e._state,topology:"triangle-list"}),r.type===O.WEBGL&&r.renderTarget.finishRenderPass()}_setupFilterTextures(e,t,r,i){if(e.backTexture=S.EMPTY,e.inputTexture=y.getOptimalTexture(t.width,t.height,e.resolution,e.antialias),e.blendRequired){r.renderTarget.finishRenderPass();const n=r.renderTarget.getRenderTarget(e.outputRenderSurface);e.backTexture=this.getBackTexture(n,t,i?.bounds)}r.renderTarget.bind(e.inputTexture,!0),r.globalUniforms.push({offset:t})}_calculateGlobalFrame(e,t,r,i,n,o){const a=e.globalFrame;a.x=t*i,a.y=r*i,a.width=n*i,a.height=o*i}_updateFilterUniforms(e,t,r,i,n,o,a,f){const c=this._filterGlobalUniforms.uniforms,l=c.uOutputFrame,u=c.uInputSize,d=c.uInputPixel,h=c.uInputClamp,p=c.uGlobalFrame,m=c.uOutputTexture;a?(l[0]=r.bounds.minX-i,l[1]=r.bounds.minY-n):(l[0]=0,l[1]=0),l[2]=e.frame.width,l[3]=e.frame.height,u[0]=e.source.width,u[1]=e.source.height,u[2]=1/u[0],u[3]=1/u[1],d[0]=e.source.pixelWidth,d[1]=e.source.pixelHeight,d[2]=1/d[0],d[3]=1/d[1],h[0]=.5*d[2],h[1]=.5*d[3],h[2]=e.frame.width*u[2]-.5*d[2],h[3]=e.frame.height*u[3]-.5*d[3];const _=this.renderer.renderTarget.rootRenderTarget.colorTexture;p[0]=i*o,p[1]=n*o,p[2]=_.source.width*o,p[3]=_.source.height*o,t instanceof S&&(t.source.resource=null);const g=this.renderer.renderTarget.getRenderTarget(t);this.renderer.renderTarget.bind(t,!!f),t instanceof S?(m[0]=t.frame.width,m[1]=t.frame.height):(m[0]=g.width,m[1]=g.height),m[2]=g.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(e){let t=this._filterStackIndex-1;for(;t>0&&this._filterStack[t].skip;)--t;return t>0&&this._filterStack[t].inputTexture?this._filterStack[t].inputTexture.source._resolution:e}_findPreviousFilterOffset(){let e=0,t=0,r=this._filterStackIndex;for(;r>0;){r--;const i=this._filterStack[r];if(!i.skip){e=i.bounds.minX,t=i.bounds.minY;break}}return{x:e,y:t}}_calculateFilterArea(e,t){if(e.renderables?Ye(e.renderables,t):e.filterEffect.filterArea?(t.clear(),t.addRect(e.filterEffect.filterArea),t.applyMatrix(e.container.worldTransform)):e.container.getFastGlobalBounds(!0,t),e.container){const i=(e.container.renderGroup||e.container.parentRenderGroup).cacheToLocalTransform;i&&t.applyMatrix(i)}}_applyFiltersToTexture(e,t){const r=e.inputTexture,i=e.bounds,n=e.filters,o=e.firstEnabledIndex,a=e.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(r.source.style,2),this._globalFilterBindGroup.setResource(e.backTexture.source,3),o===a)n[o].apply(this,r,e.outputRenderSurface,t);else{let f=e.inputTexture;const c=y.getOptimalTexture(i.width,i.height,f.source._resolution,!1);let l=c;for(let u=o;u<a;u++){const d=n[u];if(!d.enabled)continue;d.apply(this,f,l,!0);const h=f;f=l,l=h}n[a].apply(this,f,e.outputRenderSurface,t),y.returnTexture(c)}}_calculateFilterBounds(e,t,r,i,n){const o=this.renderer,a=e.bounds,f=e.filters;let c=1/0,l=0,u=!0,d=!1,h=!1,p=!0,m=-1,_=-1;for(let g=0;g<f.length;g++){const x=f[g];if(!x.enabled)continue;if(m===-1&&(m=g),_=g,c=Math.min(c,x.resolution==="inherit"?i:x.resolution),l+=x.padding,x.antialias==="off"?u=!1:x.antialias==="inherit"&&u&&(u=r),x.clipToViewport||(p=!1),!!!(x.compatibleRenderers&o.type)){h=!1;break}if(x.blendRequired&&!(o.backBuffer?.useBackBuffer??!0)){me("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),h=!1;break}h=!0,d||(d=x.blendRequired)}if(!h){e.skip=!0;return}if(p&&a.fitBounds(0,t.width/i,0,t.height/i),a.scale(c).ceil().scale(1/c).pad((l|0)*n),!a.isPositive){e.skip=!0;return}e.antialias=u,e.resolution=c,e.blendRequired=d,e.firstEnabledIndex=m,e.lastEnabledIndex=_}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let e,t=this._filterStackIndex-1;for(;t>0&&(t--,e=this._filterStack[t],!!e.skip););return e}_pushFilterData(){let e=this._filterStack[this._filterStackIndex];return e||(e=this._filterStack[this._filterStackIndex]=new Ue),this._filterStackIndex++,e}}he.extension={type:[w.WebGLSystem,w.WebGPUSystem],name:"filter"};ie.add(he);ie.add(fe);
